{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DeriveGeneric #-}
module SolcASTStrategy where

import Data.Aeson
import qualified Data.ByteString.Lazy as BL
import qualified Data.Text as T
import Data.Maybe (catMaybes, mapMaybe)
import GHC.Generics
import System.Process
import System.Exit

{-|
  Strategy 3: Solidity Compiler AST Parsing

  This module parses the Abstract Syntax Tree (AST) generated by solc
  and extracts verification conditions from assertions.

  Workflow:
  1. Compile Solidity with `solc --ast-compact-json`
  2. Parse JSON AST
  3. Extract assert statements
  4. Generate verification conditions
  5. Output TPTP format for intuition prover

  Advantages over Strategy 1 (hevm):
  - More control over VC generation
  - Can implement custom abstraction algorithms
  - Direct access to high-level contract structure
  - No need for symbolic execution

  Advantages over Strategy 2 (Yul parser):
  - Higher-level AST (Solidity, not Yul)
  - Easier to understand program logic
  - Can extract function contracts (requires/ensures)
  - Type information available
-}

-- | Simplified AST nodes (solc AST is very complex)
data SourceUnit = SourceUnit
  { absolutePath :: String
  , nodes :: [ContractDefinition]
  } deriving (Show, Generic)

instance FromJSON SourceUnit

data ContractDefinition = ContractDefinition
  { contractName :: String
  , contractKind :: String  -- "contract", "interface", "library"
  , functions :: [FunctionDefinition]
  } deriving (Show, Generic)

instance FromJSON ContractDefinition where
  parseJSON = withObject "ContractDefinition" $ \v -> do
    kind <- v .: "nodeType"
    if kind == ("ContractDefinition" :: T.Text)
      then ContractDefinition
        <$> v .: "name"
        <*> v .: "contractKind"
        <*> (v .:? "nodes" .!= [])
      else fail "Not a ContractDefinition"

data FunctionDefinition = FunctionDefinition
  { functionName :: String
  , visibility :: String
  , stateMutability :: String
  , body :: Maybe Block
  } deriving (Show, Generic)

instance FromJSON FunctionDefinition where
  parseJSON = withObject "FunctionDefinition" $ \v -> do
    kind <- v .: "nodeType"
    if kind == ("FunctionDefinition" :: T.Text)
      then FunctionDefinition
        <$> v .: "name"
        <$> v .: "visibility"
        <$> v .: "stateMutability"
        <$> v .:? "body"
      else fail "Not a FunctionDefinition"

data Block = Block
  { statements :: [Statement]
  } deriving (Show, Generic)

instance FromJSON Block

data Statement
  = ExpressionStatement Expression
  | IfStatement Expression Block (Maybe Block)
  | WhileStatement Expression Block
  | Return (Maybe Expression)
  | VariableDeclarationStatement [VariableDeclaration] (Maybe Expression)
  | OtherStatement String
  deriving (Show)

instance FromJSON Statement where
  parseJSON = withObject "Statement" $ \v -> do
    nodeType <- v .: "nodeType" :: Parser T.Text
    case nodeType of
      "ExpressionStatement" -> ExpressionStatement <$> v .: "expression"
      "IfStatement" -> IfStatement
        <$> v .: "condition"
        <$> v .: "trueBody"
        <$> v .:? "falseBody"
      "WhileStatement" -> WhileStatement
        <$> v .: "condition"
        <$> v .: "body"
      "Return" -> Return <$> v .:? "expression"
      "VariableDeclarationStatement" -> VariableDeclarationStatement
        <$> v .: "declarations"
        <$> v .:? "initialValue"
      _ -> return $ OtherStatement (T.unpack nodeType)

data VariableDeclaration = VariableDeclaration
  { varName :: String
  , varType :: String
  } deriving (Show, Generic)

instance FromJSON VariableDeclaration where
  parseJSON = withObject "VariableDeclaration" $ \v ->
    VariableDeclaration
      <$> v .: "name"
      <*> (v .: "typeName" >>= (.: "name"))

data Expression
  = FunctionCall String [Expression]  -- Function name and arguments
  | Identifier String
  | Literal String
  | BinaryOp String Expression Expression  -- operator, left, right
  | UnaryOp String Expression
  deriving (Show)

instance FromJSON Expression where
  parseJSON = withObject "Expression" $ \v -> do
    nodeType <- v .: "nodeType" :: Parser T.Text
    case nodeType of
      "FunctionCall" -> do
        funcExpr <- v .: "expression"
        funcName <- withObject "FunctionExpression" (\o -> o .: "name") funcExpr
        args <- v .:? "arguments" .!= []
        return $ FunctionCall funcName args
      "Identifier" -> Identifier <$> v .: "name"
      "Literal" -> Literal <$> v .: "value"
      "BinaryOperation" -> BinaryOp
        <$> v .: "operator"
        <$> v .: "leftExpression"
        <$> v .: "rightExpression"
      "UnaryOperation" -> UnaryOp
        <$> v .: "operator"
        <$> v .: "subExpression"
      _ -> return $ Identifier "<unknown>"

-- | Extract assert statements from a function body
extractAssertions :: Block -> [Expression]
extractAssertions (Block stmts) = concatMap extractFromStmt stmts
  where
    extractFromStmt (ExpressionStatement (FunctionCall "assert" args)) = args
    extractFromStmt (ExpressionStatement _) = []
    extractFromStmt (IfStatement _ trueBlock Nothing) = extractAssertions trueBlock
    extractFromStmt (IfStatement _ trueBlock (Just falseBlock)) =
      extractAssertions trueBlock ++ extractAssertions falseBlock
    extractFromStmt (WhileStatement _ bodyBlock) = extractAssertions bodyBlock
    extractFromStmt _ = []

-- | Extract require statements (preconditions)
extractRequires :: Block -> [Expression]
extractRequires (Block stmts) = concatMap extractFromStmt stmts
  where
    extractFromStmt (ExpressionStatement (FunctionCall "require" args)) = take 1 args  -- Only first arg is condition
    extractFromStmt (IfStatement _ trueBlock Nothing) = extractRequires trueBlock
    extractFromStmt (IfStatement _ trueBlock (Just falseBlock)) =
      extractRequires trueBlock ++ extractRequires falseBlock
    extractFromStmt _ = []

-- | Verification condition: { Preconditions } => { Postconditions }
data VC = VC
  { vcFunction :: String
  , vcPreconditions :: [Expression]
  , vcPostconditions :: [Expression]
  } deriving (Show)

-- | Generate verification condition for a function
generateVC :: FunctionDefinition -> Maybe VC
generateVC func = case body func of
  Nothing -> Nothing
  Just block -> Just $ VC
    { vcFunction = functionName func
    , vcPreconditions = extractRequires block
    , vcPostconditions = extractAssertions block
    }

-- | Convert expression to TPTP formula
exprToTPTP :: Expression -> String
exprToTPTP (Identifier name) = name
exprToTPTP (Literal val) = "$true"  -- Simplification
exprToTPTP (BinaryOp ">" left right) =
  "gt(" ++ exprToTPTP left ++ ", " ++ exprToTPTP right ++ ")"
exprToTPTP (BinaryOp "<" left right) =
  "lt(" ++ exprToTPTP left ++ ", " ++ exprToTPTP right ++ ")"
exprToTPTP (BinaryOp "==" left right) =
  "eq(" ++ exprToTPTP left ++ ", " ++ exprToTPTP right ++ ")"
exprToTPTP (BinaryOp "&&" left right) =
  "(" ++ exprToTPTP left ++ " & " ++ exprToTPTP right ++ ")"
exprToTPTP (BinaryOp "||" left right) =
  "(" ++ exprToTPTP left ++ " | " ++ exprToTPTP right ++ ")"
exprToTPTP (UnaryOp "!" expr) =
  "~" ++ exprToTPTP expr
exprToTPTP (FunctionCall name args) =
  name ++ "(" ++ unwords (map exprToTPTP args) ++ ")"
exprToTPTP _ = "unknown"

-- | Convert VC to TPTP format
vcToTPTP :: VC -> String
vcToTPTP vc =
  let pre = case vcPreconditions vc of
              [] -> "$true"
              [p] -> exprToTPTP p
              ps -> "(" ++ unwords (map (\p -> exprToTPTP p ++ " &") (init ps)) ++ " " ++ exprToTPTP (last ps) ++ ")"
      post = case vcPostconditions vc of
               [] -> "$true"
               [p] -> exprToTPTP p
               ps -> "(" ++ unwords (map (\p -> exprToTPTP p ++ " &") (init ps)) ++ " " ++ exprToTPTP (last ps) ++ ")"
      formula = if null (vcPreconditions vc)
                then post
                else "(" ++ pre ++ " => " ++ post ++ ")"
  in "fof(" ++ vcFunction vc ++ "_vc, conjecture, " ++ formula ++ ")."

-- | Main workflow
data Config = Config
  { solidityFile :: FilePath
  , outputDir :: FilePath
  } deriving (Show)

-- | Step 1: Compile to AST
compileToAST :: FilePath -> IO (Either String FilePath)
compileToAST solFile = do
  putStrLn $ "Compiling " ++ solFile ++ " to AST..."

  -- Check if solc is available
  solcCheck <- rawSystem "which" ["solc"]
  case solcCheck of
    ExitFailure _ -> return $ Left "solc not found"
    ExitSuccess -> do
      -- Compile to AST JSON
      let astFile = "build/" ++ solFile ++ ".ast.json"
      result <- rawSystem "solc"
        [ "--ast-compact-json"
        , solFile
        , "-o", "build/"
        ]

      case result of
        ExitFailure code -> return $ Left $ "Compilation failed: " ++ show code
        ExitSuccess -> return $ Right astFile

-- | Step 2: Parse AST and extract VCs
parseASTAndGenerateVCs :: FilePath -> IO (Either String [VC])
parseASTAndGenerateVCs astFile = do
  putStrLn $ "Parsing AST from " ++ astFile ++ "..."

  jsonData <- BL.readFile astFile
  case eitherDecode jsonData of
    Left err -> return $ Left $ "JSON parse error: " ++ err
    Right sourceUnit -> do
      let contracts = nodes sourceUnit
          allFuncs = concatMap functions contracts
          vcs = mapMaybe generateVC allFuncs

      putStrLn $ "Found " ++ show (length vcs) ++ " functions with VCs"
      return $ Right vcs

-- | Step 3: Export to TPTP
exportTPTP :: [VC] -> FilePath -> IO ()
exportTPTP vcs outputFile = do
  let tptpContent = unlines $ map vcToTPTP vcs
  writeFile outputFile tptpContent
  putStrLn $ "Exported VCs to " ++ outputFile

-- | Example workflow
exampleWorkflow :: Config -> IO ()
exampleWorkflow config = do
  putStrLn "=== Strategy 3: Solc AST Parsing ==="
  putStrLn ""

  putStrLn "Step 1: Compile to AST"
  astResult <- compileToAST (solidityFile config)

  case astResult of
    Left err -> putStrLn $ "Error: " ++ err
    Right astFile -> do
      putStrLn $ "✓ AST generated: " ++ astFile
      putStrLn ""

      putStrLn "Step 2: Parse AST and extract VCs"
      vcResult <- parseASTAndGenerateVCs astFile

      case vcResult of
        Left err -> putStrLn $ "Error: " ++ err
        Right vcs -> do
          putStrLn $ "✓ Extracted " ++ show (length vcs) ++ " verification conditions"
          putStrLn ""

          putStrLn "Step 3: Export to TPTP"
          let tptpFile = outputDir config ++ "/vcs.p"
          exportTPTP vcs tptpFile
          putStrLn $ "✓ TPTP file: " ++ tptpFile
          putStrLn ""

          putStrLn "Next: Run intuition prover"
          putStrLn $ "  intuition -f " ++ tptpFile

{-|
  Comparison with other strategies:

  vs Strategy 1 (hevm):
  - ✅ More control over VC generation
  - ✅ Lighter weight (no symbolic execution)
  - ✅ Can customize abstraction
  - ❌ Less proven in production
  - ❌ Need to implement EVM semantics ourselves

  vs Strategy 2 (Yul parser):
  - ✅ Higher-level AST (easier to understand)
  - ✅ Type information available
  - ✅ Can extract function contracts
  - ❌ More complex AST structure
  - ❌ Still need to handle Solidity semantics
-}
