-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParTiny
  ( happyError
  , myLexer
  , pStmt
  , pStmt1
  , pStmt2
  , pListInvariant
  , pInvariant
  , pDecl1
  , pDecl
  , pListSpecEl
  , pSpecEl
  , pFormula1
  , pFormulaD
  , pFormula
  , pListBinder
  , pBinder
  , pBExpr
  , pBExpr1
  , pExpr
  , pExpr1
  , pExpr2
  ) where

import Prelude

import qualified AbsTiny
import LexTiny

}

%name pStmt Stmt
%name pStmt1 Stmt1
%name pStmt2 Stmt2
%name pListInvariant ListInvariant
%name pInvariant Invariant
%name pDecl1 Decl1
%name pDecl Decl
%name pListSpecEl ListSpecEl
%name pSpecEl SpecEl
%name pFormula1 Formula1
%name pFormulaD FormulaD
%name pFormula Formula
%name pListBinder ListBinder
%name pBinder Binder
%name pBExpr BExpr
%name pBExpr1 BExpr1
%name pExpr Expr
%name pExpr1 Expr1
%name pExpr2 Expr2
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('             { PT _ (TS _ 1)  }
  ')'             { PT _ (TS _ 2)  }
  '*'             { PT _ (TS _ 3)  }
  '+'             { PT _ (TS _ 4)  }
  '-'             { PT _ (TS _ 5)  }
  '.'             { PT _ (TS _ 6)  }
  '/'             { PT _ (TS _ 7)  }
  '/\\'           { PT _ (TS _ 8)  }
  ':='            { PT _ (TS _ 9)  }
  ';'             { PT _ (TS _ 10) }
  '<='            { PT _ (TS _ 11) }
  '='             { PT _ (TS _ 12) }
  '==>'           { PT _ (TS _ 13) }
  '>'             { PT _ (TS _ 14) }
  '\\/'           { PT _ (TS _ 15) }
  'begin'         { PT _ (TS _ 16) }
  'call'          { PT _ (TS _ 17) }
  'do'            { PT _ (TS _ 18) }
  'else'          { PT _ (TS _ 19) }
  'end'           { PT _ (TS _ 20) }
  'exists'        { PT _ (TS _ 21) }
  'false'         { PT _ (TS _ 22) }
  'fi'            { PT _ (TS _ 23) }
  'forall'        { PT _ (TS _ 24) }
  'if'            { PT _ (TS _ 25) }
  'invariant'     { PT _ (TS _ 26) }
  'postcondition' { PT _ (TS _ 27) }
  'precondition'  { PT _ (TS _ 28) }
  'proc'          { PT _ (TS _ 29) }
  'skip'          { PT _ (TS _ 30) }
  'then'          { PT _ (TS _ 31) }
  'true'          { PT _ (TS _ 32) }
  'var'           { PT _ (TS _ 33) }
  'while'         { PT _ (TS _ 34) }
  '{'             { PT _ (TS _ 35) }
  '}'             { PT _ (TS _ 36) }
  '~'             { PT _ (TS _ 37) }
  '¬'             { PT _ (TS _ 38) }
  '∧'             { PT _ (TS _ 39) }
  '∨'             { PT _ (TS _ 40) }
  '≤'             { PT _ (TS _ 41) }
  L_Ident         { PT _ (TV $$)   }
  L_integ         { PT _ (TI $$)   }

%%

Ident :: { AbsTiny.Ident }
Ident  : L_Ident { AbsTiny.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

Stmt :: { AbsTiny.Stmt }
Stmt : Stmt1 ';' Stmt { AbsTiny.SSeq $1 $3 } | Stmt1 { $1 }

Stmt1 :: { AbsTiny.Stmt }
Stmt1
  : Ident ':=' Expr { AbsTiny.SAssgn $1 $3 }
  | 'skip' { AbsTiny.SSkip }
  | Stmt2 { $1 }

Stmt2 :: { AbsTiny.Stmt }
Stmt2
  : 'if' BExpr 'then' Stmt 'else' Stmt1 { AbsTiny.sif1 $2 $4 $6 }
  | 'if' BExpr 'then' Stmt 'fi' { AbsTiny.sif2 $2 $4 }
  | 'while' BExpr 'do' Stmt1 { AbsTiny.SWhile $2 $4 }
  | 'while' BExpr 'do' ListInvariant ';' Stmt1 { AbsTiny.SWhileInv $2 $4 $6 }
  | 'call' Ident '(' Expr ')' { AbsTiny.SCall $2 $4 }
  | 'begin' Decl ';' Stmt 'end' { AbsTiny.SBlock $2 $4 }
  | 'begin' Stmt 'end' { AbsTiny.sblocknd $2 }

ListInvariant :: { [AbsTiny.Invariant] }
ListInvariant
  : {- empty -} { [] }
  | Invariant { (:[]) $1 }
  | Invariant ';' ListInvariant { (:) $1 $3 }

Invariant :: { AbsTiny.Invariant }
Invariant : 'invariant' Formula { AbsTiny.Inv $2 }

Decl1 :: { AbsTiny.Decl }
Decl1
  : 'var' Ident '=' Expr { AbsTiny.DVar $2 $4 }
  | 'proc' Ident '(' Ident ')' '{' Stmt '}' { AbsTiny.DProc $2 $4 $7 }
  | 'proc' Ident '(' Ident ')' ListSpecEl '{' Stmt '}' { AbsTiny.DProcS $2 $4 $6 $8 }

Decl :: { AbsTiny.Decl }
Decl : Decl ';' Decl1 { AbsTiny.DSeq $1 $3 } | Decl1 { $1 }

ListSpecEl :: { [AbsTiny.SpecEl] }
ListSpecEl
  : {- empty -} { [] }
  | SpecEl { (:[]) $1 }
  | SpecEl ';' ListSpecEl { (:) $1 $3 }

SpecEl :: { AbsTiny.SpecEl }
SpecEl
  : 'precondition' Formula { AbsTiny.SpecPre $2 }
  | 'postcondition' Formula { AbsTiny.SpecPost $2 }

Formula1 :: { AbsTiny.Formula }
Formula1
  : FormulaD { AbsTiny.FormulaDA $1 }
  | Formula '==>' Formula { AbsTiny.FormulaI $1 $3 }
  | ListBinder '.' BExpr '==>' Formula { AbsTiny.FormulaQI $1 $3 $5 }
  | ListBinder '.' BExpr { AbsTiny.FormulaQS $1 $3 }
  | Formula1 '/\\' Formula { AbsTiny.FormulaAnd $1 $3 }
  | Formula1 '∧' Formula { AbsTiny.formulaA $1 $3 }
  | '(' Formula ')' { $2 }

FormulaD :: { AbsTiny.FormulaD }
FormulaD
  : BExpr '\\/' FormulaD { AbsTiny.FormulaDOr $1 $3 }
  | BExpr '∨' FormulaD { AbsTiny.formulaDO $1 $3 }
  | BExpr { AbsTiny.FormulaDB $1 }

Formula :: { AbsTiny.Formula }
Formula : Formula1 { $1 }

ListBinder :: { [AbsTiny.Binder] }
ListBinder
  : {- empty -} { [] }
  | Binder { (:[]) $1 }
  | Binder '.' ListBinder { (:) $1 $3 }

Binder :: { AbsTiny.Binder }
Binder
  : 'forall' Ident { AbsTiny.ForallB $2 }
  | 'exists' Ident { AbsTiny.ExistsB $2 }

BExpr :: { AbsTiny.BExpr }
BExpr
  : BExpr '∧' BExpr1 { AbsTiny.BAnd $1 $3 }
  | BExpr '/\\' BExpr1 { AbsTiny.band $1 $3 }
  | BExpr1 { $1 }

BExpr1 :: { AbsTiny.BExpr }
BExpr1
  : Expr '=' Expr { AbsTiny.BEq $1 $3 }
  | Expr '<=' Expr { AbsTiny.BLeq $1 $3 }
  | Expr '≤' Expr { AbsTiny.bleq $1 $3 }
  | Expr '>' Expr { AbsTiny.BGt $1 $3 }
  | '~' BExpr1 { AbsTiny.BNot $2 }
  | '¬' BExpr1 { AbsTiny.bnot $2 }
  | 'true' { AbsTiny.BTrue }
  | 'false' { AbsTiny.BFalse }
  | '(' BExpr ')' { $2 }

Expr :: { AbsTiny.Expr }
Expr
  : Expr '+' Expr1 { AbsTiny.EPlus $1 $3 }
  | Expr '-' Expr1 { AbsTiny.EMinus $1 $3 }
  | Expr1 { $1 }

Expr1 :: { AbsTiny.Expr }
Expr1
  : Expr1 '*' Expr2 { AbsTiny.EMul $1 $3 }
  | Expr1 '/' Expr2 { AbsTiny.EDiv $1 $3 }
  | Expr2 { $1 }

Expr2 :: { AbsTiny.Expr }
Expr2
  : Integer { AbsTiny.ENum $1 }
  | Ident { AbsTiny.EVar $1 }
  | '(' Expr ')' { $2 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

