-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.6.1).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -Wno-incomplete-patterns -Wno-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParYul
  ( happyError
  , myLexer
  , pYulProgram
  , pYulBlock
  , pListYulStmt
  , pYulStmt
  , pListYulTypedIdent
  , pYulTypedIdent
  , pListYulCase
  , pYulCase
  , pYulType
  , pYulExpr
  , pListYulExpr
  , pYulLiteral
  , pYulIdent
  ) where

import Prelude

import qualified AbsYul
import LexYul

}

%name pYulProgram YulProgram
%name pYulBlock YulBlock
%name pListYulStmt ListYulStmt
%name pYulStmt YulStmt
%name pListYulTypedIdent ListYulTypedIdent
%name pYulTypedIdent YulTypedIdent
%name pListYulCase ListYulCase
%name pYulCase YulCase
%name pYulType YulType
%name pYulExpr YulExpr
%name pListYulExpr ListYulExpr
%name pYulLiteral YulLiteral
%name pYulIdent YulIdent
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('         { PT _ (TS _ 1)         }
  ')'         { PT _ (TS _ 2)         }
  ','         { PT _ (TS _ 3)         }
  '->'        { PT _ (TS _ 4)         }
  ':'         { PT _ (TS _ 5)         }
  ':='        { PT _ (TS _ 6)         }
  'bool'      { PT _ (TS _ 7)         }
  'break'     { PT _ (TS _ 8)         }
  'case'      { PT _ (TS _ 9)         }
  'code'      { PT _ (TS _ 10)        }
  'continue'  { PT _ (TS _ 11)        }
  'default'   { PT _ (TS _ 12)        }
  'false'     { PT _ (TS _ 13)        }
  'for'       { PT _ (TS _ 14)        }
  'function'  { PT _ (TS _ 15)        }
  'if'        { PT _ (TS _ 16)        }
  'leave'     { PT _ (TS _ 17)        }
  'let'       { PT _ (TS _ 18)        }
  'object'    { PT _ (TS _ 19)        }
  's256'      { PT _ (TS _ 20)        }
  'switch'    { PT _ (TS _ 21)        }
  'true'      { PT _ (TS _ 22)        }
  'u128'      { PT _ (TS _ 23)        }
  'u256'      { PT _ (TS _ 24)        }
  'u32'       { PT _ (TS _ 25)        }
  'u64'       { PT _ (TS _ 26)        }
  'u8'        { PT _ (TS _ 27)        }
  '{'         { PT _ (TS _ 28)        }
  '}'         { PT _ (TS _ 29)        }
  L_Ident     { PT _ (TV $$)          }
  L_integ     { PT _ (TI $$)          }
  L_quoted    { PT _ (TL $$)          }
  L_HexNumber { PT _ (T_HexNumber $$) }

%%

Ident :: { AbsYul.Ident }
Ident  : L_Ident { AbsYul.Ident $1 }

Integer :: { Integer }
Integer  : L_integ  { (read $1) :: Integer }

String  :: { String }
String   : L_quoted { $1 }

HexNumber :: { AbsYul.HexNumber }
HexNumber  : L_HexNumber { AbsYul.HexNumber $1 }

YulProgram :: { AbsYul.YulProgram }
YulProgram
  : 'object' String '{' 'code' YulBlock '}' { AbsYul.YulObject $2 $5 }

YulBlock :: { AbsYul.YulBlock }
YulBlock : '{' ListYulStmt '}' { AbsYul.YulBlockStmt $2 }

ListYulStmt :: { [AbsYul.YulStmt] }
ListYulStmt
  : {- empty -} { [] } | YulStmt ListYulStmt { (:) $1 $2 }

YulStmt :: { AbsYul.YulStmt }
YulStmt
  : 'let' YulIdent ':=' YulExpr { AbsYul.YulVarDecl $2 $4 }
  | 'let' YulIdent ':' YulType ':=' YulExpr { AbsYul.YulVarDeclTyped $2 $4 $6 }
  | YulIdent ':=' YulExpr { AbsYul.YulAssign $1 $3 }
  | 'if' YulExpr YulBlock { AbsYul.YulIf $2 $3 }
  | 'switch' YulExpr ListYulCase { AbsYul.YulSwitch $2 $3 }
  | 'for' YulBlock YulExpr YulBlock YulBlock { AbsYul.YulFor $2 $3 $4 $5 }
  | 'break' { AbsYul.YulBreak }
  | 'continue' { AbsYul.YulContinue }
  | 'leave' { AbsYul.YulLeave }
  | 'function' YulIdent '(' ListYulTypedIdent ')' YulBlock { AbsYul.YulFunDef $2 $4 $6 }
  | 'function' YulIdent '(' ListYulTypedIdent ')' '->' ListYulTypedIdent YulBlock { AbsYul.YulFunDefRet $2 $4 $7 $8 }
  | YulExpr { AbsYul.YulExprStmt $1 }
  | YulBlock { AbsYul.YulBlockStmt2 $1 }

ListYulTypedIdent :: { [AbsYul.YulTypedIdent] }
ListYulTypedIdent
  : YulTypedIdent { (:[]) $1 }
  | YulTypedIdent ',' ListYulTypedIdent { (:) $1 $3 }

YulTypedIdent :: { AbsYul.YulTypedIdent }
YulTypedIdent
  : YulIdent { AbsYul.YulTypedId $1 }
  | YulIdent ':' YulType { AbsYul.YulTypedIdTyped $1 $3 }

ListYulCase :: { [AbsYul.YulCase] }
ListYulCase
  : {- empty -} { [] } | YulCase ListYulCase { (:) $1 $2 }

YulCase :: { AbsYul.YulCase }
YulCase
  : 'case' YulLiteral YulBlock { AbsYul.YulCaseCase $2 $3 }
  | 'default' YulBlock { AbsYul.YulCaseDefault $2 }

YulType :: { AbsYul.YulType }
YulType
  : 'bool' { AbsYul.YulTypeBool }
  | 'u256' { AbsYul.YulTypeU256 }
  | 'u8' { AbsYul.YulTypeU8 }
  | 'u32' { AbsYul.YulTypeU32 }
  | 'u64' { AbsYul.YulTypeU64 }
  | 'u128' { AbsYul.YulTypeU128 }
  | 's256' { AbsYul.YulTypeS256 }

YulExpr :: { AbsYul.YulExpr }
YulExpr
  : YulLiteral { AbsYul.YulLitExpr $1 }
  | YulIdent { AbsYul.YulIdentExpr $1 }
  | YulIdent '(' ListYulExpr ')' { AbsYul.YulFunCall $1 $3 }

ListYulExpr :: { [AbsYul.YulExpr] }
ListYulExpr
  : {- empty -} { [] }
  | YulExpr { (:[]) $1 }
  | YulExpr ',' ListYulExpr { (:) $1 $3 }

YulLiteral :: { AbsYul.YulLiteral }
YulLiteral
  : Integer { AbsYul.YulLitNum $1 }
  | HexNumber { AbsYul.YulLitHex $1 }
  | String { AbsYul.YulLitString $1 }
  | 'true' { AbsYul.YulLitBool }
  | 'false' { AbsYul.YulLitFalse }

YulIdent :: { AbsYul.YulIdent }
YulIdent : Ident { AbsYul.YulId $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

