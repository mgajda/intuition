{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use fewer imports" #-}
{-# HLINT ignore "Redundant bracket" #-}
module YulLogic where

import Prelude hiding (map)
import qualified Prelude
import Control.Monad (join)
import Data.Map (Map)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List (intercalate, stripPrefix)
import Numeric (readHex)

-- Import Tiny's logic infrastructure
import AbsTiny (BExpr(..), FormulaD (..), Formula (..), Binder(..))
import qualified AbsTiny

-- Import Yul AST types
import AbsYul

{-|
  This module provides verification condition generation for Yul programs.

  Yul is Solidity's intermediate representation with:
  - 256-bit integers (we model as Integer for now)
  - Function calls for all operations
  - Immutable variables (SSA-like)
  - No implicit type conversions
-}

-- | Type environment for Yul variables
-- Using YulType from AbsYul (generated by BNFC)
type YulVarEnv = Map String YulType

-- | Storage model (simplified - maps storage slots to values)
type YulStorage = Map Integer Integer

-- | Memory model (simplified)
type YulMemory = Map Integer Integer

-- | Yul execution state
data YulState = YulState
  { yulStorage :: YulStorage
  , yulMemory  :: YulMemory
  , yulVarEnv  :: YulVarEnv
  } deriving Show

-- | Formula environment for verification conditions
type YulFEnv = Set.Set Formula

{-|
  Built-in Yul functions fall into categories:

  1. Arithmetic: add, sub, mul, div, mod, addmod, mulmod
  2. Comparison: lt, gt, eq, iszero
  3. Bitwise: and, or, xor, not, shl, shr, sar
  4. EVM: sload, sstore, mload, mstore, keccak256, etc.
  5. Special: assert (custom), invalid (assertion failure)
-}

-- | Translate Yul expression to readable formula string
-- This creates a human-readable representation for verification
translateYulExprToString :: YulExpr -> String
translateYulExprToString expr = case expr of
  YulLitExpr (YulLitNum n) -> show n
  YulLitExpr (YulLitHex (HexNumber h)) -> h
  YulLitExpr (YulLitString s) -> show s
  YulLitExpr YulLitBool -> "true"
  YulLitExpr YulLitFalse -> "false"
  YulIdentExpr (YulId (Ident name)) -> name
  YulFunCall (YulId (Ident fname)) args -> translateFunCall fname args
  where
    translateFunCall fname args = case (fname, args) of
      -- Comparisons
      ("lt", [a, b]) -> "(" ++ translateYulExprToString a ++ " < " ++ translateYulExprToString b ++ ")"
      ("gt", [a, b]) -> "(" ++ translateYulExprToString a ++ " > " ++ translateYulExprToString b ++ ")"
      ("eq", [a, b]) -> "(" ++ translateYulExprToString a ++ " = " ++ translateYulExprToString b ++ ")"
      ("iszero", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Boolean
      ("and", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∧ " ++ translateYulExprToString b ++ ")"
      ("or", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∨ " ++ translateYulExprToString b ++ ")"
      ("not", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Arithmetic
      ("add", [a, b]) -> "(" ++ translateYulExprToString a ++ " + " ++ translateYulExprToString b ++ ")"
      ("sub", [a, b]) -> "(" ++ translateYulExprToString a ++ " - " ++ translateYulExprToString b ++ ")"
      ("mul", [a, b]) -> "(" ++ translateYulExprToString a ++ " * " ++ translateYulExprToString b ++ ")"
      ("div", [a, b]) -> "(" ++ translateYulExprToString a ++ " / " ++ translateYulExprToString b ++ ")"

      -- Generic
      _ -> fname ++ "(" ++ intercalate ", " (Prelude.map translateYulExprToString args) ++ ")"

-- | Generate Verification Condition from assertion
-- For "if cond { invalid() }", the VC is: ¬cond
-- (i.e., the condition should NOT hold for the code to be safe)
generateVC :: AssertionContext -> String
generateVC (AssertionContext location Nothing) =
  "⊥  -- Unconditional failure at " ++ location
generateVC (AssertionContext location (Just cond)) =
  let condStr = translateYulExprToString cond
  in "¬(" ++ condStr ++ ")  -- VC from " ++ location

-- | Create propositional abstraction of assertion for Intuition Prover
-- Strateg ia: Abstrakcja zdaniowa zamienia porównania arytmetyczne na zmienne atomowe
-- Przykład: iszero(gt(x, y)) => ~p  gdzie p = "x > y"
data PropositionalAbstraction = PropAbstraction
  { propFormula :: String  -- Formula in TPTP syntax for intuition prover
  , propMapping :: [(String, String)]  -- (atomic formula, propositional variable)
  , isVerifiable :: Bool  -- Can this be verified by intuition prover?
  , verifiabilityReason :: String
  } deriving Show

abstractAssertion :: YulExpr -> PropositionalAbstraction
abstractAssertion expr =
  let (atoms, atomsSet) = collectUniqueAtoms expr []
      mapping = zip atoms (Prelude.map (\n -> "p_" ++ show n) [1..])
      abstracted = substituteAtoms expr mapping
      -- Check if formula is purely propositional (no arithmetic)
      verifiable = checkVerifiable expr
      reason = if verifiable
               then "Pure propositional tautology"
               else "Contains arithmetic - needs SMT solver"
  in PropAbstraction abstracted mapping verifiable reason
  where
    -- Collect unique atomic formulas (comparisons, etc.)
    collectUniqueAtoms :: YulExpr -> [String] -> ([String], [String])
    collectUniqueAtoms e seen = case e of
      YulFunCall (YulId (Ident fname)) args -> case fname of
        -- Logical connectives - recurse
        "iszero" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        "and" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                         in (acc ++ new, s')) ([], seen) args
        "or" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                        in (acc ++ new, s')) ([], seen) args
        "not" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        -- Atomic formula - add if not seen
        _ -> let str = translateYulExprToString e
             in if str `elem` seen
                then ([], seen)
                else ([str], str : seen)
      _ -> ([], seen)

    -- Substitute atomic formulas with propositional variables
    substituteAtoms :: YulExpr -> [(String, String)] -> String
    substituteAtoms e mapping = case e of
      YulFunCall (YulId (Ident "iszero")) [arg] ->
        "~(" ++ substituteAtoms arg mapping ++ ")"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " & " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " | " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "not")) [a] ->
        "~(" ++ substituteAtoms a mapping ++ ")"
      -- Variables and literals are atomic propositions
      YulIdentExpr (YulId (Ident name)) -> name
      YulLitExpr _ -> translateYulExprToString e
      _ ->
        let str = translateYulExprToString e
        in case lookup str mapping of
             Just var -> var
             Nothing -> str  -- Use the string representation if no mapping

    -- Check if formula can be verified by intuition prover
    -- (i.e., is it a pure propositional tautology?)
    checkVerifiable :: YulExpr -> Bool
    checkVerifiable e = case e of
      -- Pure logical connectives - verifiable
      YulFunCall (YulId (Ident "iszero")) [arg] -> checkVerifiable arg
      YulFunCall (YulId (Ident "and")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "or")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "not")) [arg] -> checkVerifiable arg
      -- Anything else (gt, eq, add, etc.) needs SMT
      YulFunCall _ _ -> False
      -- Literals and variables by themselves are trivial
      YulLitExpr _ -> True
      YulIdentExpr _ -> True

{-|
  Verification condition generation for Yul

  Main differences from Tiny:
  1. All operations are function calls
  2. Variables are immutable (SSA form)
  3. Need to handle EVM storage/memory
  4. Assert statements are function calls to 'invalid'
-}

-- Example structure (will be filled in after BNFC generation):
{-
vcGenYul :: YulStmt -> YulState -> YulFEnv -> Formula -> (YulFEnv, Formula)
vcGenYul stmt state fEnv post = case stmt of
  -- Variable declaration: let x := expr
  -- In SSA form, this creates new binding
  YulVarDecl var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- Assignment (reassignment is also let in Yul)
  YulAssign var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- If statement (no else in Yul!)
  YulIf cond thenBlock ->
    let (fEnv1, pre1) = vcGenYulBlock thenBlock state fEnv post in
    let condFormula = translateYulBool cond state in
    let pre = FormulaDA (FormulaDOr condFormula (FormulaDOr (BNot condFormula) (FormulaDB post))) in
      (fEnv1, pre)

  -- Function call statement (including assert!)
  YulExprStmt (YulFunCall "invalid" []) ->
    -- This is a failed assertion - should never be reachable
    let vc = FormulaI post (FormulaDA (FormulaDB BFalse)) in
      (Set.insert vc fEnv, post)

  YulExprStmt (YulFunCall fname args) ->
    -- Handle other function calls (sstore, mstore, etc.)
    -- For now, assume they don't affect postcondition
    (fEnv, post)

  _ -> (fEnv, post) -- Default case
-}

-- Helper to substitute in formulas (reuse from Logic.hs)
-- We'll need to convert between Yul and Tiny expression types

-- | Print Yul verification conditions
printYulVCs :: [String] -> String
printYulVCs [] = ""
printYulVCs (vc:rest) = vc ++ "\n" ++ printYulVCs rest

-- | Example: Extract assertions from Yul code
-- An assertion in Yul is typically:
--   if iszero(condition) { invalid() }
-- We want to extract 'condition' as a VC

-- For now, we'll extract locations and contexts of invalid() calls
data AssertionContext = AssertionContext
  { assertLocation :: String
  , assertCondition :: Maybe YulExpr  -- The condition guarding the invalid()
  } deriving Show

extractAssertions :: YulProgram -> [AssertionContext]
extractAssertions (YulObject name block) = extractFromBlock Nothing block

-- Extract assertions from a block, tracking the current guard condition
extractFromBlock :: Maybe YulExpr -> YulBlock -> [AssertionContext]
extractFromBlock guard (YulBlockStmt stmts) = concatMap (extractFromStmt guard) stmts

-- Extract assertions from a statement
extractFromStmt :: Maybe YulExpr -> YulStmt -> [AssertionContext]
extractFromStmt guard stmt = case stmt of
  -- If statement: if cond { block }
  -- The block executes only when cond is true
  YulIf cond block ->
    let assertions = extractFromBlock (Just cond) block
        -- Check if this is an assertion pattern: if cond { invalid() }
        isAssertion = case block of
          YulBlockStmt [YulExprStmt (YulFunCall (YulId (Ident "invalid")) [])] -> True
          _ -> False
    in if isAssertion
       then [AssertionContext "if-guard" (Just cond)]
       else assertions

  -- Expression statement: might be invalid()
  YulExprStmt expr -> case expr of
    YulFunCall (YulId (Ident "invalid")) [] ->
      [AssertionContext "direct-call" guard]
    _ -> []

  -- Function definition: search inside the body
  YulFunDef _ _ block -> extractFromBlock Nothing block
  YulFunDefRet _ _ _ block -> extractFromBlock Nothing block

  -- Block statement
  YulBlockStmt2 block -> extractFromBlock guard block

  -- Switch statement
  YulSwitch expr cases -> concatMap extractFromCase cases
    where
      extractFromCase (YulCaseCase _ block) = extractFromBlock Nothing block
      extractFromCase (YulCaseDefault block) = extractFromBlock Nothing block

  -- For loop: for init cond post body
  YulFor initBlock condExpr postBlock bodyBlock ->
    extractFromBlock Nothing initBlock ++
    extractFromBlock Nothing postBlock ++
    extractFromBlock (Just condExpr) bodyBlock

  -- Multi-value declarations and assignments (Yul feature)
  -- These don't directly contain assertions, but we search their RHS
  YulVarDeclMulti _ _ expr -> []
  YulAssignMulti _ _ expr -> []

  -- Other statements don't contain assertions
  _ -> []

-- | Theory Axioms for Common Operations
-- These axioms allow Intuition Prover to reason about arithmetic comparisons
-- without full arithmetic support

data TheoryAxiom = TheoryAxiom
  { axiomName :: String
  , axiomFormula :: String  -- TPTP format
  , axiomDescription :: String
  } deriving Show

-- | Standard axioms for ordering relations (gt, lt, eq)
orderingAxioms :: [TheoryAxiom]
orderingAxioms =
  [ TheoryAxiom "transitivity_gt"
      "![X,Y,Z]: ((gt(X,Y) & gt(Y,Z)) => gt(X,Z))"
      "Transitivity: if X > Y and Y > Z then X > Z"

  , TheoryAxiom "asymmetry_gt"
      "![X,Y]: (gt(X,Y) => ~gt(Y,X))"
      "Asymmetry: if X > Y then not Y > X"

  , TheoryAxiom "trichotomy"
      "![X,Y]: (gt(X,Y) | eq(X,Y) | gt(Y,X))"
      "Trichotomy: for any X,Y exactly one holds: X>Y, X=Y, or Y>X"

  , TheoryAxiom "eq_reflexive"
      "![X]: eq(X,X)"
      "Reflexivity: X = X"

  , TheoryAxiom "eq_symmetric"
      "![X,Y]: (eq(X,Y) => eq(Y,X))"
      "Symmetry: if X = Y then Y = X"

  , TheoryAxiom "eq_transitive"
      "![X,Y,Z]: ((eq(X,Y) & eq(Y,Z)) => eq(X,Z))"
      "Transitivity of equality"
  ]

-- | Boolean algebra axioms for iszero, and, or
booleanAxioms :: [TheoryAxiom]
booleanAxioms =
  [ TheoryAxiom "double_negation"
      "![P]: (iszero(iszero(P)) <=> P)"
      "Double negation elimination"

  , TheoryAxiom "demorgan_and"
      "![P,Q]: (iszero(and(P,Q)) <=> (iszero(P) | iszero(Q)))"
      "De Morgan's law for AND"

  , TheoryAxiom "demorgan_or"
      "![P,Q]: (iszero(or(P,Q)) <=> (iszero(P) & iszero(Q)))"
      "De Morgan's law for OR"
  ]

-- | Detect which axioms are needed for a given assertion
detectNeededAxioms :: YulExpr -> [TheoryAxiom]
detectNeededAxioms expr =
  let hasGt = hasOperation "gt" expr
      hasLt = hasOperation "lt" expr
      hasEq = hasOperation "eq" expr
      hasIszero = hasOperation "iszero" expr
      hasAnd = hasOperation "and" expr
      hasOr = hasOperation "or" expr
  in concat
      [ if hasGt || hasLt || hasEq then orderingAxioms else []
      , if hasIszero || hasAnd || hasOr then booleanAxioms else []
      ]
  where
    hasOperation :: String -> YulExpr -> Bool
    hasOperation op e = case e of
      YulFunCall (YulId (Ident fname)) args ->
        fname == op || any (hasOperation op) args
      _ -> False

-- | Generate TPTP file with axioms and VC
generateTPTPWithAxioms :: AssertionContext -> String
generateTPTPWithAxioms ctx = case assertCondition ctx of
  Nothing -> "% Unconditional failure - no VC to generate"
  Just expr ->
    let axioms = detectNeededAxioms expr
        axiomDecls = Prelude.map formatAxiom (zip [1..] axioms)
        vc = generateVCFormula expr
    in unlines $
        ["% Verification Condition with Theory Axioms"
        , "% Location: " ++ assertLocation ctx
        , ""
        , "% Theory Axioms:"
        ] ++ axiomDecls ++
        ["", "% Verification Condition:"
        , "fof(vc, conjecture, " ++ vc ++ ")."
        ]
  where
    formatAxiom (n, ax) =
      "fof(" ++ axiomName ax ++ ", axiom, " ++ axiomFormula ax ++ "). % " ++ axiomDescription ax

    generateVCFormula expr =
      "~(" ++ exprToTPTP expr ++ ")"

    exprToTPTP :: YulExpr -> String
    exprToTPTP e = case e of
      YulFunCall (YulId (Ident "gt")) [a, b] ->
        "gt(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "lt")) [a, b] ->
        "lt(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "eq")) [a, b] ->
        "eq(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "iszero")) [a] ->
        "iszero(" ++ exprToTPTP a ++ ")"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        "(" ++ exprToTPTP a ++ " & " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        "(" ++ exprToTPTP a ++ " | " ++ exprToTPTP b ++ ")"
      YulIdentExpr (YulId (Ident name)) -> name
      YulLitExpr (YulLitNum n) -> show n
      _ -> "unknown"

-- =============================================================================
-- Weakest Precondition Calculus for Yul
-- =============================================================================

{-|
  Weakest Precondition (WP) calculus computes the precondition needed
  for a postcondition to hold after executing a statement.

  Key rules:
  - wp(x := e, φ) = φ[e/x]  (substitute e for x)
  - wp(S1; S2, φ) = wp(S1, wp(S2, φ))
  - wp(if cond { invalid() }, φ) = ¬cond ∧ φ
  - wp(if cond { S }, φ) = (cond → wp(S, φ)) ∧ (¬cond → φ)

  This gives us VCs with proper data flow!
-}

type Substitution = Map.Map String YulExpr

-- | Compute weakest precondition for a Yul statement
weakestPrecondition :: YulStmt -> YulExpr -> YulExpr
weakestPrecondition stmt postcond = case stmt of
  -- Assignment: wp(x := e, φ) = φ[e/x]
  YulAssign (YulId (Ident var)) expr ->
    substituteInExpr var expr postcond

  -- Variable declaration with init: wp(let x := e, φ) = φ[e/x]
  YulVarDecl (YulId (Ident var)) expr ->
    substituteInExpr var expr postcond

  -- If with invalid: wp(if cond { invalid() }, φ) = ¬cond ∧ φ
  YulIf cond (YulBlockStmt [YulExprStmt (YulFunCall (YulId (Ident "invalid")) [])]) ->
    -- The invalid should NOT execute, so ¬cond must hold
    andExpr (notExpr cond) postcond

  -- If with body: wp(if cond { S }, φ) = (cond → wp(S, φ)) ∧ (¬cond → φ)
  YulIf cond (YulBlockStmt stmts) ->
    let wpBody = weakestPreconditionBlock stmts postcond
        thenPart = impliesExpr cond wpBody
        elsePart = impliesExpr (notExpr cond) postcond
    in andExpr thenPart elsePart

  -- Block statement: unwrap and process
  YulBlockStmt2 (YulBlockStmt stmts) ->
    weakestPreconditionBlock stmts postcond

  -- Expression statement (like function call): assume no effect on postcondition
  YulExprStmt _ -> postcond

  -- Function definition: skip (handle separately)
  YulFunDef {} -> postcond
  YulFunDefRet {} -> postcond

  _ -> postcond

-- | WP for a sequence of statements (process in reverse)
weakestPreconditionBlock :: [YulStmt] -> YulExpr -> YulExpr
weakestPreconditionBlock stmts postcond =
  foldr weakestPrecondition postcond (reverse stmts)

-- | Substitute expression for variable in another expression
substituteInExpr :: String -> YulExpr -> YulExpr -> YulExpr
substituteInExpr var replacement expr = case expr of
  YulIdentExpr (YulId (Ident name))
    | name == var -> replacement
    | otherwise -> expr

  YulFunCall fname args ->
    YulFunCall fname (Prelude.map (substituteInExpr var replacement) args)

  YulLitExpr _ -> expr

  _ -> expr

-- Helper constructors for logical operations
notExpr :: YulExpr -> YulExpr
notExpr e = YulFunCall (YulId (Ident "iszero")) [e]

andExpr :: YulExpr -> YulExpr -> YulExpr
andExpr a b = YulFunCall (YulId (Ident "and")) [a, b]

impliesExpr :: YulExpr -> YulExpr -> YulExpr
impliesExpr a b = YulFunCall (YulId (Ident "or")) [notExpr a, b]  -- a → b ≡ ¬a ∨ b

-- =============================================================================
-- Z3 Integration with Bitvector Theory
-- =============================================================================

{-|
  Now with WP calculus, we can generate proper VCs with data flow,
  then encode them in SMT-LIB with bitvector theory for uint256 semantics.
-}

-- | Generate SMT-LIB2 with bitvector theory for Z3
generateSMTLIB2_BV :: AssertionContext -> String
generateSMTLIB2_BV ctx = case assertCondition ctx of
  Nothing -> "; Unconditional failure - no VC to generate"
  Just expr ->
    let variables = collectVarsBV expr
        varDecls = Prelude.map (\v -> "(declare-const " ++ v ++ " (_ BitVec 256))") variables
        vc = exprToSMT_BV expr
    in unlines $
        ["; Verification Condition for: " ++ assertLocation ctx
        , "; Using bitvector theory (QF_BV) for uint256 semantics"
        , ""
        , "(set-logic QF_BV)"
        , ""
        , "; Variable declarations (256-bit bitvectors)"
        ] ++ varDecls ++
        [""
        , "; Verification condition"
        , "(assert " ++ vc ++ ")"
        , ""
        , "(check-sat)"
        , "(get-model)"
        ]
  where
    collectVarsBV :: YulExpr -> [String]
    collectVarsBV e = Set.toList $ collectVars e Set.empty
      where
        collectVars :: YulExpr -> Set.Set String -> Set.Set String
        collectVars expr vars = case expr of
          YulIdentExpr (YulId (Ident name)) -> Set.insert name vars
          YulFunCall _ args -> foldr collectVars vars args
          _ -> vars

    exprToSMT_BV :: YulExpr -> String
    exprToSMT_BV e = case e of
      YulLitExpr (YulLitNum n) ->
        "(_ bv" ++ show n ++ " 256)"
      YulLitExpr (YulLitHex (HexNumber h)) ->
        case stripPrefix "0x" h of
          Just hexStr -> case readHex hexStr :: [(Integer, String)] of
            [(n, "")] -> "(_ bv" ++ show n ++ " 256)"
            _ -> "(_ bv0 256)"
          Nothing -> "(_ bv0 256)"
      YulIdentExpr (YulId (Ident name)) -> name

      -- Arithmetic (with wraparound)
      YulFunCall (YulId (Ident "add")) [a, b] ->
        "(bvadd " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "sub")) [a, b] ->
        "(bvsub " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "mul")) [a, b] ->
        "(bvmul " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "div")) [a, b] ->
        "(bvudiv " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "mod")) [a, b] ->
        "(bvurem " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"

      -- Comparisons (unsigned)
      YulFunCall (YulId (Ident "gt")) [a, b] ->
        "(bvugt " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "lt")) [a, b] ->
        "(bvult " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "eq")) [a, b] ->
        "(= " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"

      -- Boolean operations
      YulFunCall (YulId (Ident "iszero")) [a] ->
        case a of
          YulFunCall (YulId (Ident fname)) _
            | fname `elem` ["gt", "lt", "eq", "and", "or", "not", "iszero"] ->
                "(not " ++ exprToSMT_BV a ++ ")"
          _ -> "(= " ++ exprToSMT_BV a ++ " (_ bv0 256))"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        -- Check if boolean and or bitwise and
        case (a, b) of
          (YulFunCall (YulId (Ident fa)) _, YulFunCall (YulId (Ident fb)) _)
            | fa `elem` ["gt", "lt", "eq", "iszero"] && fb `elem` ["gt", "lt", "eq", "iszero"] ->
                "(and " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
          _ -> "(bvand " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        case (a, b) of
          (YulFunCall (YulId (Ident fa)) _, YulFunCall (YulId (Ident fb)) _)
            | fa `elem` ["gt", "lt", "eq", "iszero"] && fb `elem` ["gt", "lt", "eq", "iszero"] ->
                "(or " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
          _ -> "(bvor " ++ exprToSMT_BV a ++ " " ++ exprToSMT_BV b ++ ")"
      YulFunCall (YulId (Ident "not")) [a] ->
        "(bvnot " ++ exprToSMT_BV a ++ ")"

      _ -> "(_ bv0 256)"

{-|
  Integration strategy:

  1. Parse Yul with BNFC-generated parser
  2. Traverse AST to find 'invalid()' calls (failed assertions)
  3. Generate VCs ensuring invalid() is never reached
  4. **Theory Axioms** (Branch 1): FOL axioms - failed
  5. **Presburger** (Branch 2): QF_LIA - right logic, needs data flow
  6. **Z3 Bitvectors** (Branch 3): QF_BV - full uint256 semantics
-}
