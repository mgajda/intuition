{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use fewer imports" #-}
{-# HLINT ignore "Redundant bracket" #-}
module YulLogic where

import Prelude hiding (map)
import qualified Prelude
import Control.Monad (join)
import Data.Map (Map)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List (intercalate)

-- Import Tiny's logic infrastructure
import AbsTiny (BExpr(..), FormulaD (..), Formula (..), Binder(..))
import qualified AbsTiny

-- Import Yul AST types
import AbsYul

{-|
  This module provides verification condition generation for Yul programs.

  Yul is Solidity's intermediate representation with:
  - 256-bit integers (we model as Integer for now)
  - Function calls for all operations
  - Immutable variables (SSA-like)
  - No implicit type conversions
-}

-- | Type environment for Yul variables
-- Using YulType from AbsYul (generated by BNFC)
type YulVarEnv = Map String YulType

-- | Storage model (simplified - maps storage slots to values)
type YulStorage = Map Integer Integer

-- | Memory model (simplified)
type YulMemory = Map Integer Integer

-- | Yul execution state
data YulState = YulState
  { yulStorage :: YulStorage
  , yulMemory  :: YulMemory
  , yulVarEnv  :: YulVarEnv
  } deriving Show

-- | Formula environment for verification conditions
type YulFEnv = Set.Set Formula

{-|
  Built-in Yul functions fall into categories:

  1. Arithmetic: add, sub, mul, div, mod, addmod, mulmod
  2. Comparison: lt, gt, eq, iszero
  3. Bitwise: and, or, xor, not, shl, shr, sar
  4. EVM: sload, sstore, mload, mstore, keccak256, etc.
  5. Special: assert (custom), invalid (assertion failure)
-}

-- | Translate Yul expression to readable formula string
-- This creates a human-readable representation for verification
translateYulExprToString :: YulExpr -> String
translateYulExprToString expr = case expr of
  YulLitExpr (YulLitNum n) -> show n
  YulLitExpr (YulLitHex (HexNumber h)) -> h
  YulLitExpr (YulLitString s) -> show s
  YulLitExpr YulLitBool -> "true"
  YulLitExpr YulLitFalse -> "false"
  YulIdentExpr (YulId (Ident name)) -> name
  YulFunCall (YulId (Ident fname)) args -> translateFunCall fname args
  where
    translateFunCall fname args = case (fname, args) of
      -- Comparisons
      ("lt", [a, b]) -> "(" ++ translateYulExprToString a ++ " < " ++ translateYulExprToString b ++ ")"
      ("gt", [a, b]) -> "(" ++ translateYulExprToString a ++ " > " ++ translateYulExprToString b ++ ")"
      ("eq", [a, b]) -> "(" ++ translateYulExprToString a ++ " = " ++ translateYulExprToString b ++ ")"
      ("iszero", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Boolean
      ("and", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∧ " ++ translateYulExprToString b ++ ")"
      ("or", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∨ " ++ translateYulExprToString b ++ ")"
      ("not", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Arithmetic
      ("add", [a, b]) -> "(" ++ translateYulExprToString a ++ " + " ++ translateYulExprToString b ++ ")"
      ("sub", [a, b]) -> "(" ++ translateYulExprToString a ++ " - " ++ translateYulExprToString b ++ ")"
      ("mul", [a, b]) -> "(" ++ translateYulExprToString a ++ " * " ++ translateYulExprToString b ++ ")"
      ("div", [a, b]) -> "(" ++ translateYulExprToString a ++ " / " ++ translateYulExprToString b ++ ")"

      -- Generic
      _ -> fname ++ "(" ++ intercalate ", " (Prelude.map translateYulExprToString args) ++ ")"

-- | Generate Verification Condition from assertion
-- For "if cond { invalid() }", the VC is: ¬cond
-- (i.e., the condition should NOT hold for the code to be safe)
generateVC :: AssertionContext -> String
generateVC (AssertionContext location Nothing) =
  "⊥  -- Unconditional failure at " ++ location
generateVC (AssertionContext location (Just cond)) =
  let condStr = translateYulExprToString cond
  in "¬(" ++ condStr ++ ")  -- VC from " ++ location

-- | Create propositional abstraction of assertion for Intuition Prover
-- Strateg ia: Abstrakcja zdaniowa zamienia porównania arytmetyczne na zmienne atomowe
-- Przykład: iszero(gt(x, y)) => ~p  gdzie p = "x > y"
data PropositionalAbstraction = PropAbstraction
  { propFormula :: String  -- Formula in TPTP syntax for intuition prover
  , propMapping :: [(String, String)]  -- (atomic formula, propositional variable)
  , isVerifiable :: Bool  -- Can this be verified by intuition prover?
  , verifiabilityReason :: String
  } deriving Show

abstractAssertion :: YulExpr -> PropositionalAbstraction
abstractAssertion expr =
  let (atoms, atomsSet) = collectUniqueAtoms expr []
      mapping = zip atoms (Prelude.map (\n -> "p_" ++ show n) [1..])
      abstracted = substituteAtoms expr mapping
      -- Check if formula is purely propositional (no arithmetic)
      verifiable = checkVerifiable expr
      reason = if verifiable
               then "Pure propositional tautology"
               else "Contains arithmetic - needs SMT solver"
  in PropAbstraction abstracted mapping verifiable reason
  where
    -- Collect unique atomic formulas (comparisons, etc.)
    collectUniqueAtoms :: YulExpr -> [String] -> ([String], [String])
    collectUniqueAtoms e seen = case e of
      YulFunCall (YulId (Ident fname)) args -> case fname of
        -- Logical connectives - recurse
        "iszero" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        "and" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                         in (acc ++ new, s')) ([], seen) args
        "or" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                        in (acc ++ new, s')) ([], seen) args
        "not" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        -- Atomic formula - add if not seen
        _ -> let str = translateYulExprToString e
             in if str `elem` seen
                then ([], seen)
                else ([str], str : seen)
      _ -> ([], seen)

    -- Substitute atomic formulas with propositional variables
    substituteAtoms :: YulExpr -> [(String, String)] -> String
    substituteAtoms e mapping = case e of
      YulFunCall (YulId (Ident "iszero")) [arg] ->
        "~(" ++ substituteAtoms arg mapping ++ ")"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " & " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " | " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "not")) [a] ->
        "~(" ++ substituteAtoms a mapping ++ ")"
      -- Variables and literals are atomic propositions
      YulIdentExpr (YulId (Ident name)) -> name
      YulLitExpr _ -> translateYulExprToString e
      _ ->
        let str = translateYulExprToString e
        in case lookup str mapping of
             Just var -> var
             Nothing -> str  -- Use the string representation if no mapping

    -- Check if formula can be verified by intuition prover
    -- (i.e., is it a pure propositional tautology?)
    checkVerifiable :: YulExpr -> Bool
    checkVerifiable e = case e of
      -- Pure logical connectives - verifiable
      YulFunCall (YulId (Ident "iszero")) [arg] -> checkVerifiable arg
      YulFunCall (YulId (Ident "and")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "or")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "not")) [arg] -> checkVerifiable arg
      -- Anything else (gt, eq, add, etc.) needs SMT
      YulFunCall _ _ -> False
      -- Literals and variables by themselves are trivial
      YulLitExpr _ -> True
      YulIdentExpr _ -> True

{-|
  Verification condition generation for Yul

  Main differences from Tiny:
  1. All operations are function calls
  2. Variables are immutable (SSA form)
  3. Need to handle EVM storage/memory
  4. Assert statements are function calls to 'invalid'
-}

-- Example structure (will be filled in after BNFC generation):
{-
vcGenYul :: YulStmt -> YulState -> YulFEnv -> Formula -> (YulFEnv, Formula)
vcGenYul stmt state fEnv post = case stmt of
  -- Variable declaration: let x := expr
  -- In SSA form, this creates new binding
  YulVarDecl var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- Assignment (reassignment is also let in Yul)
  YulAssign var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- If statement (no else in Yul!)
  YulIf cond thenBlock ->
    let (fEnv1, pre1) = vcGenYulBlock thenBlock state fEnv post in
    let condFormula = translateYulBool cond state in
    let pre = FormulaDA (FormulaDOr condFormula (FormulaDOr (BNot condFormula) (FormulaDB post))) in
      (fEnv1, pre)

  -- Function call statement (including assert!)
  YulExprStmt (YulFunCall "invalid" []) ->
    -- This is a failed assertion - should never be reachable
    let vc = FormulaI post (FormulaDA (FormulaDB BFalse)) in
      (Set.insert vc fEnv, post)

  YulExprStmt (YulFunCall fname args) ->
    -- Handle other function calls (sstore, mstore, etc.)
    -- For now, assume they don't affect postcondition
    (fEnv, post)

  _ -> (fEnv, post) -- Default case
-}

-- Helper to substitute in formulas (reuse from Logic.hs)
-- We'll need to convert between Yul and Tiny expression types

-- | Print Yul verification conditions
printYulVCs :: [String] -> String
printYulVCs [] = ""
printYulVCs (vc:rest) = vc ++ "\n" ++ printYulVCs rest

-- | Example: Extract assertions from Yul code
-- An assertion in Yul is typically:
--   if iszero(condition) { invalid() }
-- We want to extract 'condition' as a VC

-- For now, we'll extract locations and contexts of invalid() calls
data AssertionContext = AssertionContext
  { assertLocation :: String
  , assertCondition :: Maybe YulExpr  -- The condition guarding the invalid()
  } deriving Show

extractAssertions :: YulProgram -> [AssertionContext]
extractAssertions (YulObject name block) = extractFromBlock Nothing block

-- Extract assertions from a block, tracking the current guard condition
extractFromBlock :: Maybe YulExpr -> YulBlock -> [AssertionContext]
extractFromBlock guard (YulBlockStmt stmts) = concatMap (extractFromStmt guard) stmts

-- Extract assertions from a statement
extractFromStmt :: Maybe YulExpr -> YulStmt -> [AssertionContext]
extractFromStmt guard stmt = case stmt of
  -- If statement: if cond { block }
  -- The block executes only when cond is true
  YulIf cond block ->
    let assertions = extractFromBlock (Just cond) block
        -- Check if this is an assertion pattern: if cond { invalid() }
        isAssertion = case block of
          YulBlockStmt [YulExprStmt (YulFunCall (YulId (Ident "invalid")) [])] -> True
          _ -> False
    in if isAssertion
       then [AssertionContext "if-guard" (Just cond)]
       else assertions

  -- Expression statement: might be invalid()
  YulExprStmt expr -> case expr of
    YulFunCall (YulId (Ident "invalid")) [] ->
      [AssertionContext "direct-call" guard]
    _ -> []

  -- Function definition: search inside the body
  YulFunDef _ _ block -> extractFromBlock Nothing block
  YulFunDefRet _ _ _ block -> extractFromBlock Nothing block

  -- Block statement
  YulBlockStmt2 block -> extractFromBlock guard block

  -- Switch statement
  YulSwitch expr cases -> concatMap extractFromCase cases
    where
      extractFromCase (YulCaseCase _ block) = extractFromBlock Nothing block
      extractFromCase (YulCaseDefault block) = extractFromBlock Nothing block

  -- For loop: for init cond post body
  YulFor initBlock condExpr postBlock bodyBlock ->
    extractFromBlock Nothing initBlock ++
    extractFromBlock Nothing postBlock ++
    extractFromBlock (Just condExpr) bodyBlock

  -- Multi-value declarations and assignments (Yul feature)
  -- These don't directly contain assertions, but we search their RHS
  YulVarDeclMulti _ _ expr -> []
  YulAssignMulti _ _ expr -> []

  -- Other statements don't contain assertions
  _ -> []

{-|
  Integration strategy:

  1. Parse Yul with BNFC-generated parser
  2. Traverse AST to find 'invalid()' calls (failed assertions)
  3. Generate VCs ensuring invalid() is never reached
  4. Output to SMT-LIB or use with intuition prover
-}
