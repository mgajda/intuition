{-# OPTIONS_GHC -Wno-unrecognised-pragmas #-}
{-# HLINT ignore "Use fewer imports" #-}
{-# HLINT ignore "Redundant bracket" #-}
module YulLogic where

import Prelude hiding (map)
import qualified Prelude
import Control.Monad (join)
import Data.Map (Map)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.List (intercalate, stripPrefix, isInfixOf)
import Numeric (readHex)

-- Import Tiny's logic infrastructure
import AbsTiny (BExpr(..), FormulaD (..), Formula (..), Binder(..))
import qualified AbsTiny

-- Import Yul AST types
import AbsYul

{-|
  This module provides verification condition generation for Yul programs.

  Yul is Solidity's intermediate representation with:
  - 256-bit integers (we model as Integer for now)
  - Function calls for all operations
  - Immutable variables (SSA-like)
  - No implicit type conversions
-}

-- | Type environment for Yul variables
-- Using YulType from AbsYul (generated by BNFC)
type YulVarEnv = Map String YulType

-- | Storage model (simplified - maps storage slots to values)
type YulStorage = Map Integer Integer

-- | Memory model (simplified)
type YulMemory = Map Integer Integer

-- | Yul execution state
data YulState = YulState
  { yulStorage :: YulStorage
  , yulMemory  :: YulMemory
  , yulVarEnv  :: YulVarEnv
  } deriving Show

-- | Formula environment for verification conditions
type YulFEnv = Set.Set Formula

{-|
  Built-in Yul functions fall into categories:

  1. Arithmetic: add, sub, mul, div, mod, addmod, mulmod
  2. Comparison: lt, gt, eq, iszero
  3. Bitwise: and, or, xor, not, shl, shr, sar
  4. EVM: sload, sstore, mload, mstore, keccak256, etc.
  5. Special: assert (custom), invalid (assertion failure)
-}

-- | Translate Yul expression to readable formula string
-- This creates a human-readable representation for verification
translateYulExprToString :: YulExpr -> String
translateYulExprToString expr = case expr of
  YulLitExpr (YulLitNum n) -> show n
  YulLitExpr (YulLitHex (HexNumber h)) -> h
  YulLitExpr (YulLitString s) -> show s
  YulLitExpr YulLitBool -> "true"
  YulLitExpr YulLitFalse -> "false"
  YulIdentExpr (YulId (Ident name)) -> name
  YulFunCall (YulId (Ident fname)) args -> translateFunCall fname args
  where
    translateFunCall fname args = case (fname, args) of
      -- Comparisons
      ("lt", [a, b]) -> "(" ++ translateYulExprToString a ++ " < " ++ translateYulExprToString b ++ ")"
      ("gt", [a, b]) -> "(" ++ translateYulExprToString a ++ " > " ++ translateYulExprToString b ++ ")"
      ("eq", [a, b]) -> "(" ++ translateYulExprToString a ++ " = " ++ translateYulExprToString b ++ ")"
      ("iszero", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Boolean
      ("and", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∧ " ++ translateYulExprToString b ++ ")"
      ("or", [a, b]) -> "(" ++ translateYulExprToString a ++ " ∨ " ++ translateYulExprToString b ++ ")"
      ("not", [a]) -> "¬(" ++ translateYulExprToString a ++ ")"

      -- Arithmetic
      ("add", [a, b]) -> "(" ++ translateYulExprToString a ++ " + " ++ translateYulExprToString b ++ ")"
      ("sub", [a, b]) -> "(" ++ translateYulExprToString a ++ " - " ++ translateYulExprToString b ++ ")"
      ("mul", [a, b]) -> "(" ++ translateYulExprToString a ++ " * " ++ translateYulExprToString b ++ ")"
      ("div", [a, b]) -> "(" ++ translateYulExprToString a ++ " / " ++ translateYulExprToString b ++ ")"

      -- Generic
      _ -> fname ++ "(" ++ intercalate ", " (Prelude.map translateYulExprToString args) ++ ")"

-- | Generate Verification Condition from assertion
-- For "if cond { invalid() }", the VC is: ¬cond
-- (i.e., the condition should NOT hold for the code to be safe)
generateVC :: AssertionContext -> String
generateVC (AssertionContext location Nothing) =
  "⊥  -- Unconditional failure at " ++ location
generateVC (AssertionContext location (Just cond)) =
  let condStr = translateYulExprToString cond
  in "¬(" ++ condStr ++ ")  -- VC from " ++ location

-- | Create propositional abstraction of assertion for Intuition Prover
-- Strateg ia: Abstrakcja zdaniowa zamienia porównania arytmetyczne na zmienne atomowe
-- Przykład: iszero(gt(x, y)) => ~p  gdzie p = "x > y"
data PropositionalAbstraction = PropAbstraction
  { propFormula :: String  -- Formula in TPTP syntax for intuition prover
  , propMapping :: [(String, String)]  -- (atomic formula, propositional variable)
  , isVerifiable :: Bool  -- Can this be verified by intuition prover?
  , verifiabilityReason :: String
  } deriving Show

abstractAssertion :: YulExpr -> PropositionalAbstraction
abstractAssertion expr =
  let (atoms, atomsSet) = collectUniqueAtoms expr []
      mapping = zip atoms (Prelude.map (\n -> "p_" ++ show n) [1..])
      abstracted = substituteAtoms expr mapping
      -- Check if formula is purely propositional (no arithmetic)
      verifiable = checkVerifiable expr
      reason = if verifiable
               then "Pure propositional tautology"
               else "Contains arithmetic - needs SMT solver"
  in PropAbstraction abstracted mapping verifiable reason
  where
    -- Collect unique atomic formulas (comparisons, etc.)
    collectUniqueAtoms :: YulExpr -> [String] -> ([String], [String])
    collectUniqueAtoms e seen = case e of
      YulFunCall (YulId (Ident fname)) args -> case fname of
        -- Logical connectives - recurse
        "iszero" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        "and" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                         in (acc ++ new, s')) ([], seen) args
        "or" -> foldl (\(acc, s) arg -> let (new, s') = collectUniqueAtoms arg s
                                        in (acc ++ new, s')) ([], seen) args
        "not" -> foldl (\(acc, s) arg -> collectUniqueAtoms arg s) (seen, seen) args
        -- Atomic formula - add if not seen
        _ -> let str = translateYulExprToString e
             in if str `elem` seen
                then ([], seen)
                else ([str], str : seen)
      _ -> ([], seen)

    -- Substitute atomic formulas with propositional variables
    substituteAtoms :: YulExpr -> [(String, String)] -> String
    substituteAtoms e mapping = case e of
      YulFunCall (YulId (Ident "iszero")) [arg] ->
        "~(" ++ substituteAtoms arg mapping ++ ")"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " & " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        "(" ++ substituteAtoms a mapping ++ " | " ++ substituteAtoms b mapping ++ ")"
      YulFunCall (YulId (Ident "not")) [a] ->
        "~(" ++ substituteAtoms a mapping ++ ")"
      -- Variables and literals are atomic propositions
      YulIdentExpr (YulId (Ident name)) -> name
      YulLitExpr _ -> translateYulExprToString e
      _ ->
        let str = translateYulExprToString e
        in case lookup str mapping of
             Just var -> var
             Nothing -> str  -- Use the string representation if no mapping

    -- Check if formula can be verified by intuition prover
    -- (i.e., is it a pure propositional tautology?)
    checkVerifiable :: YulExpr -> Bool
    checkVerifiable e = case e of
      -- Pure logical connectives - verifiable
      YulFunCall (YulId (Ident "iszero")) [arg] -> checkVerifiable arg
      YulFunCall (YulId (Ident "and")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "or")) args -> all checkVerifiable args
      YulFunCall (YulId (Ident "not")) [arg] -> checkVerifiable arg
      -- Anything else (gt, eq, add, etc.) needs SMT
      YulFunCall _ _ -> False
      -- Literals and variables by themselves are trivial
      YulLitExpr _ -> True
      YulIdentExpr _ -> True

{-|
  Verification condition generation for Yul

  Main differences from Tiny:
  1. All operations are function calls
  2. Variables are immutable (SSA form)
  3. Need to handle EVM storage/memory
  4. Assert statements are function calls to 'invalid'
-}

-- Example structure (will be filled in after BNFC generation):
{-
vcGenYul :: YulStmt -> YulState -> YulFEnv -> Formula -> (YulFEnv, Formula)
vcGenYul stmt state fEnv post = case stmt of
  -- Variable declaration: let x := expr
  -- In SSA form, this creates new binding
  YulVarDecl var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- Assignment (reassignment is also let in Yul)
  YulAssign var expr ->
    let pre = substF post var (translateYulExpr expr state) in
      (fEnv, pre)

  -- If statement (no else in Yul!)
  YulIf cond thenBlock ->
    let (fEnv1, pre1) = vcGenYulBlock thenBlock state fEnv post in
    let condFormula = translateYulBool cond state in
    let pre = FormulaDA (FormulaDOr condFormula (FormulaDOr (BNot condFormula) (FormulaDB post))) in
      (fEnv1, pre)

  -- Function call statement (including assert!)
  YulExprStmt (YulFunCall "invalid" []) ->
    -- This is a failed assertion - should never be reachable
    let vc = FormulaI post (FormulaDA (FormulaDB BFalse)) in
      (Set.insert vc fEnv, post)

  YulExprStmt (YulFunCall fname args) ->
    -- Handle other function calls (sstore, mstore, etc.)
    -- For now, assume they don't affect postcondition
    (fEnv, post)

  _ -> (fEnv, post) -- Default case
-}

-- Helper to substitute in formulas (reuse from Logic.hs)
-- We'll need to convert between Yul and Tiny expression types

-- | Print Yul verification conditions
printYulVCs :: [String] -> String
printYulVCs [] = ""
printYulVCs (vc:rest) = vc ++ "\n" ++ printYulVCs rest

-- | Example: Extract assertions from Yul code
-- An assertion in Yul is typically:
--   if iszero(condition) { invalid() }
-- We want to extract 'condition' as a VC

-- For now, we'll extract locations and contexts of invalid() calls
data AssertionContext = AssertionContext
  { assertLocation :: String
  , assertCondition :: Maybe YulExpr  -- The condition guarding the invalid()
  } deriving Show

extractAssertions :: YulProgram -> [AssertionContext]
extractAssertions (YulObject name block) = extractFromBlock Nothing block

-- Extract assertions from a block, tracking the current guard condition
extractFromBlock :: Maybe YulExpr -> YulBlock -> [AssertionContext]
extractFromBlock guard (YulBlockStmt stmts) = concatMap (extractFromStmt guard) stmts

-- Extract assertions from a statement
extractFromStmt :: Maybe YulExpr -> YulStmt -> [AssertionContext]
extractFromStmt guard stmt = case stmt of
  -- If statement: if cond { block }
  -- The block executes only when cond is true
  YulIf cond block ->
    let assertions = extractFromBlock (Just cond) block
        -- Check if this is an assertion pattern: if cond { invalid() }
        isAssertion = case block of
          YulBlockStmt [YulExprStmt (YulFunCall (YulId (Ident "invalid")) [])] -> True
          _ -> False
    in if isAssertion
       then [AssertionContext "if-guard" (Just cond)]
       else assertions

  -- Expression statement: might be invalid()
  YulExprStmt expr -> case expr of
    YulFunCall (YulId (Ident "invalid")) [] ->
      [AssertionContext "direct-call" guard]
    _ -> []

  -- Function definition: search inside the body
  YulFunDef _ _ block -> extractFromBlock Nothing block
  YulFunDefRet _ _ _ block -> extractFromBlock Nothing block

  -- Block statement
  YulBlockStmt2 block -> extractFromBlock guard block

  -- Switch statement
  YulSwitch expr cases -> concatMap extractFromCase cases
    where
      extractFromCase (YulCaseCase _ block) = extractFromBlock Nothing block
      extractFromCase (YulCaseDefault block) = extractFromBlock Nothing block

  -- For loop: for init cond post body
  YulFor initBlock condExpr postBlock bodyBlock ->
    extractFromBlock Nothing initBlock ++
    extractFromBlock Nothing postBlock ++
    extractFromBlock (Just condExpr) bodyBlock

  -- Multi-value declarations and assignments (Yul feature)
  -- These don't directly contain assertions, but we search their RHS
  YulVarDeclMulti _ _ expr -> []
  YulAssignMulti _ _ expr -> []

  -- Other statements don't contain assertions
  _ -> []

-- | Theory Axioms for Common Operations
-- These axioms allow Intuition Prover to reason about arithmetic comparisons
-- without full arithmetic support

data TheoryAxiom = TheoryAxiom
  { axiomName :: String
  , axiomFormula :: String  -- TPTP format
  , axiomDescription :: String
  } deriving Show

-- | Standard axioms for ordering relations (gt, lt, eq)
orderingAxioms :: [TheoryAxiom]
orderingAxioms =
  [ TheoryAxiom "transitivity_gt"
      "![X,Y,Z]: ((gt(X,Y) & gt(Y,Z)) => gt(X,Z))"
      "Transitivity: if X > Y and Y > Z then X > Z"

  , TheoryAxiom "asymmetry_gt"
      "![X,Y]: (gt(X,Y) => ~gt(Y,X))"
      "Asymmetry: if X > Y then not Y > X"

  , TheoryAxiom "trichotomy"
      "![X,Y]: (gt(X,Y) | eq(X,Y) | gt(Y,X))"
      "Trichotomy: for any X,Y exactly one holds: X>Y, X=Y, or Y>X"

  , TheoryAxiom "eq_reflexive"
      "![X]: eq(X,X)"
      "Reflexivity: X = X"

  , TheoryAxiom "eq_symmetric"
      "![X,Y]: (eq(X,Y) => eq(Y,X))"
      "Symmetry: if X = Y then Y = X"

  , TheoryAxiom "eq_transitive"
      "![X,Y,Z]: ((eq(X,Y) & eq(Y,Z)) => eq(X,Z))"
      "Transitivity of equality"
  ]

-- | Boolean algebra axioms for iszero, and, or
booleanAxioms :: [TheoryAxiom]
booleanAxioms =
  [ TheoryAxiom "double_negation"
      "![P]: (iszero(iszero(P)) <=> P)"
      "Double negation elimination"

  , TheoryAxiom "demorgan_and"
      "![P,Q]: (iszero(and(P,Q)) <=> (iszero(P) | iszero(Q)))"
      "De Morgan's law for AND"

  , TheoryAxiom "demorgan_or"
      "![P,Q]: (iszero(or(P,Q)) <=> (iszero(P) & iszero(Q)))"
      "De Morgan's law for OR"
  ]

-- | Detect which axioms are needed for a given assertion
detectNeededAxioms :: YulExpr -> [TheoryAxiom]
detectNeededAxioms expr =
  let hasGt = hasOperation "gt" expr
      hasLt = hasOperation "lt" expr
      hasEq = hasOperation "eq" expr
      hasIszero = hasOperation "iszero" expr
      hasAnd = hasOperation "and" expr
      hasOr = hasOperation "or" expr
  in concat
      [ if hasGt || hasLt || hasEq then orderingAxioms else []
      , if hasIszero || hasAnd || hasOr then booleanAxioms else []
      ]
  where
    hasOperation :: String -> YulExpr -> Bool
    hasOperation op e = case e of
      YulFunCall (YulId (Ident fname)) args ->
        fname == op || any (hasOperation op) args
      _ -> False

-- | Generate TPTP file with axioms and VC
generateTPTPWithAxioms :: AssertionContext -> String
generateTPTPWithAxioms ctx = case assertCondition ctx of
  Nothing -> "% Unconditional failure - no VC to generate"
  Just expr ->
    let axioms = detectNeededAxioms expr
        axiomDecls = Prelude.map formatAxiom (zip [1..] axioms)
        vc = generateVCFormula expr
    in unlines $
        ["% Verification Condition with Theory Axioms"
        , "% Location: " ++ assertLocation ctx
        , ""
        , "% Theory Axioms:"
        ] ++ axiomDecls ++
        ["", "% Verification Condition:"
        , "fof(vc, conjecture, " ++ vc ++ ")."
        ]
  where
    formatAxiom (n, ax) =
      "fof(" ++ axiomName ax ++ ", axiom, " ++ axiomFormula ax ++ "). % " ++ axiomDescription ax

    generateVCFormula expr =
      "~(" ++ exprToTPTP expr ++ ")"

    exprToTPTP :: YulExpr -> String
    exprToTPTP e = case e of
      YulFunCall (YulId (Ident "gt")) [a, b] ->
        "gt(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "lt")) [a, b] ->
        "lt(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "eq")) [a, b] ->
        "eq(" ++ exprToTPTP a ++ ", " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "iszero")) [a] ->
        "iszero(" ++ exprToTPTP a ++ ")"
      YulFunCall (YulId (Ident "and")) [a, b] ->
        "(" ++ exprToTPTP a ++ " & " ++ exprToTPTP b ++ ")"
      YulFunCall (YulId (Ident "or")) [a, b] ->
        "(" ++ exprToTPTP a ++ " | " ++ exprToTPTP b ++ ")"
      YulIdentExpr (YulId (Ident name)) -> name
      YulLitExpr (YulLitNum n) -> show n
      _ -> "unknown"

-- =============================================================================
-- Presburger Arithmetic Decision Procedure
-- =============================================================================

{-|
  Presburger arithmetic is decidable and includes:
  - Linear integer arithmetic: +, - (but not * or / of variables)
  - Comparisons: <, >, ≤, ≥, =, ≠
  - Boolean logic: ∧, ∨, ¬

  For Yul/EVM:
  - uint256 arithmetic is modulo 2^256
  - Most overflow/underflow checks are Presburger-decidable
  - Operations like add(x, const), sub(x, const) are linear
  - Comparisons gt(x, y), lt(x, y), eq(x, y) are supported
-}

data PresburgerClassification = PresburgerClassification
  { isPresburger :: Bool
  , reason :: String
  , nonLinearOps :: [String]  -- Operations that break Presburger
  } deriving Show

-- | Check if a Yul expression is in Presburger arithmetic
classifyPresburger :: YulExpr -> PresburgerClassification
classifyPresburger expr =
  let (isP, nonLinOps) = checkExpr expr
      reasonText = if isP
                   then "Linear arithmetic with comparisons - Presburger decidable"
                   else "Contains non-linear operations: " ++ show nonLinOps
  in PresburgerClassification isP reasonText nonLinOps
  where
    checkExpr :: YulExpr -> (Bool, [String])
    checkExpr e = case e of
      YulLitExpr _ -> (True, [])
      YulIdentExpr _ -> (True, [])

      -- Linear operations: add, sub (when used linearly)
      YulFunCall (YulId (Ident "add")) [a, b] ->
        checkBinary "add" a b
      YulFunCall (YulId (Ident "sub")) [a, b] ->
        checkBinary "sub" a b

      -- Comparisons: always OK for Presburger
      YulFunCall (YulId (Ident "gt")) [a, b] ->
        checkBinary "gt" a b
      YulFunCall (YulId (Ident "lt")) [a, b] ->
        checkBinary "lt" a b
      YulFunCall (YulId (Ident "eq")) [a, b] ->
        checkBinary "eq" a b

      -- Boolean: always OK
      YulFunCall (YulId (Ident "iszero")) [a] ->
        checkExpr a
      YulFunCall (YulId (Ident "and")) [a, b] ->
        checkBinary "and" a b
      YulFunCall (YulId (Ident "or")) [a, b] ->
        checkBinary "or" a b
      YulFunCall (YulId (Ident "not")) [a] ->
        checkExpr a

      -- Non-linear: mul, div, mod
      YulFunCall (YulId (Ident fname)) args
        | fname `elem` ["mul", "div", "mod", "mulmod", "addmod", "exp", "shl", "shr"] ->
            let childResults = Prelude.map checkExpr args
                allNonLin = concat (Prelude.map snd childResults)
            in (False, fname : allNonLin)

      -- Unknown operations: assume non-linear
      YulFunCall (YulId (Ident fname)) args ->
        let childResults = Prelude.map checkExpr args
            anyNonLin = any (not . fst) childResults
            allNonLin = concat (Prelude.map snd childResults)
        in if anyNonLin
           then (False, fname : allNonLin)
           else (True, [])

      _ -> (False, ["unknown"])

    checkBinary :: String -> YulExpr -> YulExpr -> (Bool, [String])
    checkBinary _op a b =
      let (aOk, aNonLin) = checkExpr a
          (bOk, bNonLin) = checkExpr b
      in (aOk && bOk, aNonLin ++ bNonLin)

-- =============================================================================
-- SMT-LIB Helper Functions
-- =============================================================================

-- | Collect all variables from an expression
collectVariables :: YulExpr -> [String]
collectVariables e = Set.toList $ collectVars e Set.empty
  where
    collectVars :: YulExpr -> Set.Set String -> Set.Set String
    collectVars expr vars = case expr of
      YulIdentExpr (YulId (Ident name)) -> Set.insert name vars
      YulFunCall _ args -> foldr collectVars vars args
      _ -> vars

-- | Convert Yul expression to SMT-LIB2 syntax
exprToSMT :: YulExpr -> String
exprToSMT e = case e of
  YulLitExpr (YulLitNum n) -> show n
  YulLitExpr (YulLitHex (HexNumber h)) ->
    -- Convert hex to decimal for SMT-LIB
    case stripPrefix "0x" h of
      Just hexStr -> case readHex hexStr :: [(Integer, String)] of
        [(n, "")] -> show n
        _ -> h
      Nothing -> h
  YulIdentExpr (YulId (Ident name)) -> name

  -- Arithmetic
  YulFunCall (YulId (Ident "add")) [a, b] ->
    "(+ " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "sub")) [a, b] ->
    "(- " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"

  -- Comparisons
  YulFunCall (YulId (Ident "gt")) [a, b] ->
    "(> " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "lt")) [a, b] ->
    "(< " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "eq")) [a, b] ->
    "(= " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"

  -- Boolean
  YulFunCall (YulId (Ident "iszero")) [a] ->
    -- iszero(x) = NOT(x) for boolean expressions, or (= x 0) for integer expressions
    -- Check if subexpression is a comparison (returns boolean)
    case a of
      YulFunCall (YulId (Ident fname)) _
        | fname `elem` ["gt", "lt", "eq", "and", "or", "not", "iszero"] ->
            "(not " ++ exprToSMT a ++ ")"
      _ -> "(= " ++ exprToSMT a ++ " 0)"
  YulFunCall (YulId (Ident "and")) [a, b] ->
    "(and " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "or")) [a, b] ->
    "(or " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "not")) [a] ->
    "(not " ++ exprToSMT a ++ ")"

  -- Non-linear (best effort - may not be correct)
  YulFunCall (YulId (Ident "mul")) [a, b] ->
    "(* " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"
  YulFunCall (YulId (Ident "div")) [a, b] ->
    "(div " ++ exprToSMT a ++ " " ++ exprToSMT b ++ ")"

  _ -> "unknown"

-- =============================================================================
-- Function Inlining for WP
-- =============================================================================

-- | Extract function definitions from a Yul program
type FunctionEnv = [(String, ([String], YulBlock, [String]))]  -- (name, (params, body, returns))

extractFunctions :: YulProgram -> FunctionEnv
extractFunctions (YulObject _ (YulBlockStmt stmts)) = extractFromStmts stmts
  where
    extractFromStmts :: [YulStmt] -> FunctionEnv
    extractFromStmts [] = []
    extractFromStmts (stmt:rest) = extractFromStmt stmt ++ extractFromStmts rest

    extractFromStmt :: YulStmt -> FunctionEnv
    extractFromStmt (YulFunDefRet (YulId (Ident fname)) params retVars body) =
      let paramNames = extractParamNames params
          retNames = extractParamNames retVars
      in [(fname, (paramNames, body, retNames))]
    extractFromStmt (YulFunDef (YulId (Ident fname)) params body) =
      let paramNames = extractParamNames params
      in [(fname, (paramNames, body, []))]
    extractFromStmt _ = []

    extractParamNames :: [YulTypedIdent] -> [String]
    extractParamNames params = [name | param <- params, Just name <- [getParamName param]]
      where
        getParamName (YulTypedId (YulId (Ident n))) = Just n
        getParamName (YulTypedIdTyped (YulId (Ident n)) _) = Just n
        getParamName _ = Nothing

-- | Inline a function call expression
inlineFunctionCall :: FunctionEnv -> YulExpr -> YulExpr
inlineFunctionCall funcs expr = case expr of
  YulFunCall (YulId (Ident fname)) args ->
    -- First, recursively inline in arguments
    let inlinedArgs = Prelude.map (inlineFunctionCall funcs) args
        result = case lookup fname funcs of
          Just (params, YulBlockStmt bodyStmts, [retVar]) ->
            -- Simple case: single return value
            -- Find the assignment to the return variable
            case findReturnValue bodyStmts retVar of
              Just retExpr ->
                -- Substitute arguments for parameters in the return expression
                let substituted = foldr (\(param, arg) e -> substituteInExpr param arg e)
                                       retExpr (zip params inlinedArgs)
                in inlineFunctionCall funcs substituted  -- Recursively inline the result
              Nothing ->
                YulFunCall (YulId (Ident fname)) inlinedArgs  -- Keep call but with inlined args
          _other ->
            YulFunCall (YulId (Ident fname)) inlinedArgs  -- Keep call but with inlined args
    in result

  -- Other expressions: keep as is
  _ -> expr

-- | Find the value assigned to a return variable in function body
findReturnValue :: [YulStmt] -> String -> Maybe YulExpr
findReturnValue [] _ = Nothing
findReturnValue (stmt:rest) retVar = case stmt of
  YulAssign (YulId (Ident var)) expr | var == retVar -> Just expr
  _ -> findReturnValue rest retVar

-- | Try to compute WP for simple block patterns
-- Returns (wpFormula, isWP) where isWP indicates if WP was computed
tryComputeWP :: YulProgram -> AssertionContext -> (YulExpr, Bool)
tryComputeWP prog@(YulObject _ (YulBlockStmt stmts)) ctx =
  case assertCondition ctx of
    Nothing -> (YulLitExpr (YulLitNum 0), False)  -- No condition
    Just cond ->
      -- Extract function definitions for inlining
      let funcs = extractFunctions prog
          -- Start WP computation with postcondition = true
          postcondTrue = YulLitExpr (YulLitNum 1)  -- Represents "true"
          result = tryWPForBlock funcs stmts postcondTrue
      in case result of
        Just wpExpr ->
          -- Inline function calls in the WP expression
          let inlined = inlineFunctionCall funcs wpExpr
          in (inlined, True)
        Nothing -> (cond, False)  -- Fall back to original condition
  where
    -- Try to compute WP for statements in a block leading to an assertion
    tryWPForBlock :: FunctionEnv -> [YulStmt] -> YulExpr -> Maybe YulExpr
    tryWPForBlock _ [] postcond = Just postcond
    tryWPForBlock funcs (stmt:rest) postcond = do
      restWP <- tryWPForBlock funcs rest postcond
      Just (weakestPrecondition stmt restWP)

-- | Generate SMT-LIB2 format for Presburger arithmetic
-- Uses LIA (Linear Integer Arithmetic) theory
-- Now with optional WP computation!
generateSMTLIB2 :: AssertionContext -> String
generateSMTLIB2 ctx = generateSMTLIB2_NoWP ctx

-- | Generate SMT-LIB2 with WP for a program
generateSMTLIB2_WP :: YulProgram -> AssertionContext -> String
generateSMTLIB2_WP prog ctx = case assertCondition ctx of
  Nothing -> "; Unconditional failure - no VC to generate"
  Just expr ->
    let (wpExpr, isWP) = tryComputeWP prog ctx
        classification = classifyPresburger wpExpr
        variables = collectVariables wpExpr
        varDecls = Prelude.map (\v -> "(declare-const " ++ v ++ " Int)") variables
        vc = exprToSMT wpExpr
        uint256Max = show ((2 :: Integer) ^ (256 :: Integer) - 1)
        rangeConstraints = Prelude.map (\v -> "(assert (and (>= " ++ v ++ " 0) (<= " ++ v ++ " " ++ uint256Max ++ ")))") variables
    in unlines $
        ["; Verification Condition for: " ++ assertLocation ctx
        , "; WP Computed: " ++ show isWP
        , "; Classification: " ++ (if isPresburger classification then "Presburger" else "Non-Presburger")
        , "; Reason: " ++ reason classification
        , ""
        , "(set-logic QF_LIA)  ; Quantifier-Free Linear Integer Arithmetic"
        , ""
        , "; Variable declarations"
        ] ++ varDecls ++
        [""
        , "; uint256 range constraints (0 <= var <= 2^256-1)"
        ] ++ rangeConstraints ++
        [""
        , "; Verification condition"
        , "(assert " ++ vc ++ ")"
        , ""
        , "(check-sat)"
        , "(get-model)"
        ]

-- | Original SMT-LIB2 generation without WP
generateSMTLIB2_NoWP :: AssertionContext -> String
generateSMTLIB2_NoWP ctx = case assertCondition ctx of
  Nothing -> "; Unconditional failure - no VC to generate"
  Just expr ->
    let classification = classifyPresburger expr
        variables = collectVariables expr
        varDecls = Prelude.map (\v -> "(declare-const " ++ v ++ " Int)") variables
        vc = exprToSMT expr
        uint256Max = show ((2 :: Integer) ^ (256 :: Integer) - 1)  -- 2^256 - 1
        rangeConstraints = Prelude.map (\v -> "(assert (and (>= " ++ v ++ " 0) (<= " ++ v ++ " " ++ uint256Max ++ ")))") variables
    in unlines $
        ["; Verification Condition for: " ++ assertLocation ctx
        , "; Classification: " ++ (if isPresburger classification then "Presburger" else "Non-Presburger")
        , "; Reason: " ++ reason classification
        , ""
        , "(set-logic QF_LIA)  ; Quantifier-Free Linear Integer Arithmetic"
        , ""
        , "; Variable declarations"
        ] ++ varDecls ++
        [""
        , "; uint256 range constraints (0 <= var <= 2^256-1)"
        ] ++ rangeConstraints ++
        [""
        , "; Verification condition: prove that this is unsatisfiable"
        , "; (i.e., the negation should be valid)"
        , "(assert " ++ vc ++ ")"
        , ""
        , "(check-sat)"
        , "(get-model)"
        ]

-- =============================================================================
-- Weakest Precondition Calculus for Yul
-- =============================================================================

-- | Compute weakest precondition for a Yul statement
weakestPrecondition :: YulStmt -> YulExpr -> YulExpr
weakestPrecondition stmt postcond = case stmt of
  -- Assignment: wp(x := e, φ) = φ[e/x]
  YulAssign (YulId (Ident var)) expr ->
    substituteInExpr var expr postcond

  -- Variable declaration with init: wp(let x := e, φ) = φ[e/x]
  YulVarDecl (YulId (Ident var)) expr ->
    substituteInExpr var expr postcond

  -- If with invalid: wp(if cond { invalid() }, φ) = ¬cond ∧ φ
  YulIf cond (YulBlockStmt [YulExprStmt (YulFunCall (YulId (Ident "invalid")) [])]) ->
    andExpr (notExpr cond) postcond

  -- If with body: wp(if cond { S }, φ) = (cond → wp(S, φ)) ∧ (¬cond → φ)
  YulIf cond (YulBlockStmt stmts) ->
    let wpBody = weakestPreconditionBlock stmts postcond
        thenPart = impliesExpr cond wpBody
        elsePart = impliesExpr (notExpr cond) postcond
    in andExpr thenPart elsePart

  -- Block statement
  YulBlockStmt2 (YulBlockStmt stmts) ->
    weakestPreconditionBlock stmts postcond

  -- Expression statement: assume no effect
  YulExprStmt _ -> postcond

  -- Function definitions: skip
  YulFunDef {} -> postcond
  YulFunDefRet {} -> postcond

  _ -> postcond

-- | WP for sequence of statements (process in reverse)
weakestPreconditionBlock :: [YulStmt] -> YulExpr -> YulExpr
weakestPreconditionBlock stmts postcond =
  foldr weakestPrecondition postcond (reverse stmts)

-- | Substitute expression for variable
substituteInExpr :: String -> YulExpr -> YulExpr -> YulExpr
substituteInExpr var replacement expr = case expr of
  YulIdentExpr (YulId (Ident name))
    | name == var -> replacement
    | otherwise -> expr
  YulFunCall fname args ->
    YulFunCall fname (Prelude.map (substituteInExpr var replacement) args)
  YulLitExpr _ -> expr
  _ -> expr

-- Helper constructors for logical operations
notExpr :: YulExpr -> YulExpr
notExpr e = YulFunCall (YulId (Ident "iszero")) [e]

andExpr :: YulExpr -> YulExpr -> YulExpr
andExpr a b = YulFunCall (YulId (Ident "and")) [a, b]

impliesExpr :: YulExpr -> YulExpr -> YulExpr
impliesExpr a b = YulFunCall (YulId (Ident "or")) [notExpr a, b]

-- =============================================================================
-- Intuition Prover Integration with WP
-- =============================================================================

-- | Result of verification with Intuition + Presburger
data IntuitionVerificationResult = IntuitionVerificationResult
  { intuitionSuccess :: Bool
  , wpComputed :: Bool
  , propositionalFormula :: String
  , arithmeticAtoms :: [(String, String)]  -- (atom_id, atom_expr)
  , atomCheckResults :: [(String, Bool)]   -- (atom_id, is_valid)
  , verificationMessage :: String
  } deriving Show

-- | Verify using Intuition prover + Presburger arithmetic
-- This implements the homegrown SMT approach from HOMEGROWN_SMT_DESIGN.md
verifyWithIntuitionWP :: YulProgram -> AssertionContext -> IntuitionVerificationResult
verifyWithIntuitionWP prog ctx = case assertCondition ctx of
  Nothing -> IntuitionVerificationResult
    { intuitionSuccess = False
    , wpComputed = False
    , propositionalFormula = ""
    , arithmeticAtoms = []
    , atomCheckResults = []
    , verificationMessage = "Unconditional failure - no VC to generate"
    }
  Just _ ->
    let -- Step 1: Compute WP
        (wpExpr, isWP) = tryComputeWP prog ctx

        -- Step 2: Propositional abstraction
        abstraction = abstractAssertion wpExpr
        propForm = propFormula abstraction
        atoms = propMapping abstraction

        -- Step 3: Propositional structure is always verifiable after abstraction
        -- Intuition can handle any propositional formula (Boolean logic)
        intuitionOk = True

        -- Step 4: Check arithmetic atoms (simple constant evaluation for now)
        atomResults = Prelude.map (\(atomExpr, atomId) -> (atomId, checkArithmeticAtom atomExpr)) atoms

        -- Step 5: Overall result
        allAtomsValid = all snd atomResults
        success = intuitionOk && allAtomsValid

        message = if not isWP then
                    "WP computation failed - falling back to direct checking"
                  else if null atoms then
                    "✅ VERIFIED by Intuition (purely propositional)!"
                  else if not allAtomsValid then
                    "Propositional structure verified by Intuition, but arithmetic atoms failed: " ++
                    show (filter (not . snd) atomResults)
                  else
                    "✅ VERIFIED by Intuition + Presburger!"

    in IntuitionVerificationResult
       { intuitionSuccess = success
       , wpComputed = isWP
       , propositionalFormula = propForm
       , arithmeticAtoms = Prelude.map (\(e, i) -> (i, e)) atoms
       , atomCheckResults = atomResults
       , verificationMessage = message
       }

-- | Simple arithmetic atom checker (MVP - constant evaluation only)
-- Returns True if the atom is valid (always true)
checkArithmeticAtom :: String -> Bool
checkArithmeticAtom atomExpr =
  -- For MVP, we check if it's a tautology like "43 > 42" or "(43 > 42)"
  -- A real implementation would use Cooper's Algorithm or Omega Test

  -- Remove parentheses and parse
  let cleaned = filter (/= '(') $ filter (/= ')') atomExpr
      parts = words cleaned
  in case parts of
    -- Pattern: num1 > num2
    [n1, ">", n2] ->
      case (reads n1 :: [(Integer, String)], reads n2 :: [(Integer, String)]) of
        ([(a, "")], [(b, "")]) -> a > b
        _ -> False  -- Can't evaluate - not constants

    -- Pattern: num1 < num2
    [n1, "<", n2] ->
      case (reads n1 :: [(Integer, String)], reads n2 :: [(Integer, String)]) of
        ([(a, "")], [(b, "")]) -> a < b
        _ -> False

    -- Pattern: num1 = num2
    [n1, "=", n2] ->
      case (reads n1 :: [(Integer, String)], reads n2 :: [(Integer, String)]) of
        ([(a, "")], [(b, "")]) -> a == b
        _ -> False

    -- Has free variables - WP didn't fully compute
    _ -> if any (\var -> var `isInfixOf` atomExpr) ["result", "x", "y", "newValue", "balance", "amount"]
         then False
         else True  -- No variables and no pattern match - assume valid (conservative)

{-|
  Integration strategy:

  1. Parse Yul with BNFC-generated parser
  2. Traverse AST to find 'invalid()' calls (failed assertions)
  3. Generate VCs ensuring invalid() is never reached
  4. **Intuition + Presburger + WP**: Homegrown SMT with data flow!
     - WP computes preconditions with concrete values
     - Intuition verifies propositional structure (fast!)
     - Presburger module checks arithmetic atoms (decidable!)
-}
